<!DOCTYPE html>
<html>

<head>
  <title>Brief introdunction to pointers</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    /**
   * prism.js Github theme based on GitHub's theme.
   * @author Sam Clarke
   */
    code[class*="language-"],
    pre[class*="language-"] {
      color: #333;
      background: none;
      font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
      text-align: left;
      white-space: pre;
      word-spacing: normal;
      word-break: normal;
      word-wrap: normal;
      line-height: 1.4;

      -moz-tab-size: 8;
      -o-tab-size: 8;
      tab-size: 8;

      -webkit-hyphens: none;
      -moz-hyphens: none;
      -ms-hyphens: none;
      hyphens: none;
    }

    /* Code blocks */
    pre[class*="language-"] {
      padding: .8em;
      overflow: auto;
      /* border: 1px solid #ddd; */
      border-radius: 3px;
      /* background: #fff; */
      background: #f5f5f5;
    }

    /* Inline code */
    :not(pre)>code[class*="language-"] {
      padding: .1em;
      border-radius: .3em;
      white-space: normal;
      background: #f5f5f5;
    }

    .token.comment,
    .token.blockquote {
      color: #969896;
    }

    .token.cdata {
      color: #183691;
    }

    .token.doctype,
    .token.punctuation,
    .token.variable,
    .token.macro.property {
      color: #333;
    }

    .token.operator,
    .token.important,
    .token.keyword,
    .token.rule,
    .token.builtin {
      color: #a71d5d;
    }

    .token.string,
    .token.url,
    .token.regex,
    .token.attr-value {
      color: #183691;
    }

    .token.property,
    .token.number,
    .token.boolean,
    .token.entity,
    .token.atrule,
    .token.constant,
    .token.symbol,
    .token.command,
    .token.code {
      color: #0086b3;
    }

    .token.tag,
    .token.selector,
    .token.prolog {
      color: #63a35c;
    }

    .token.function,
    .token.namespace,
    .token.pseudo-element,
    .token.class,
    .token.class-name,
    .token.pseudo-class,
    .token.id,
    .token.url-reference .token.variable,
    .token.attr-name {
      color: #795da3;
    }

    .token.entity {
      cursor: help;
    }

    .token.title,
    .token.title .token.punctuation {
      font-weight: bold;
      color: #1d3e81;
    }

    .token.list {
      color: #ed6a43;
    }

    .token.inserted {
      background-color: #eaffea;
      color: #55a532;
    }

    .token.deleted {
      background-color: #ffecec;
      color: #bd2c00;
    }

    .token.bold {
      font-weight: bold;
    }

    .token.italic {
      font-style: italic;
    }


    /* JSON */
    .language-json .token.property {
      color: #183691;
    }

    .language-markup .token.tag .token.punctuation {
      color: #333;
    }

    /* CSS */
    code.language-css,
    .language-css .token.function {
      color: #0086b3;
    }

    /* YAML */
    .language-yaml .token.atrule {
      color: #63a35c;
    }

    code.language-yaml {
      color: #183691;
    }

    /* Ruby */
    .language-ruby .token.function {
      color: #333;
    }

    /* Markdown */
    .language-markdown .token.url {
      color: #795da3;
    }

    /* Makefile */
    .language-makefile .token.symbol {
      color: #795da3;
    }

    .language-makefile .token.variable {
      color: #183691;
    }

    .language-makefile .token.builtin {
      color: #0086b3;
    }

    /* Bash */
    .language-bash .token.keyword {
      color: #0086b3;
    }

    /* highlight */
    pre[data-line] {
      position: relative;
      padding: 1em 0 1em 3em;
    }

    pre[data-line] .line-highlight-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      background-color: transparent;
      display: block;
      width: 100%;
    }

    pre[data-line] .line-highlight {
      position: absolute;
      left: 0;
      right: 0;
      padding: inherit 0;
      margin-top: 1em;
      background: hsla(24, 20%, 50%, .08);
      background: linear-gradient(to right, hsla(24, 20%, 50%, .1) 70%, hsla(24, 20%, 50%, 0));
      pointer-events: none;
      line-height: inherit;
      white-space: pre;
    }

    pre[data-line] .line-highlight:before,
    pre[data-line] .line-highlight[data-end]:after {
      content: attr(data-start);
      position: absolute;
      top: .4em;
      left: .6em;
      min-width: 1em;
      padding: 0 .5em;
      background-color: hsla(24, 20%, 50%, .4);
      color: hsl(24, 20%, 95%);
      font: bold 65%/1.5 sans-serif;
      text-align: center;
      vertical-align: .3em;
      border-radius: 999px;
      text-shadow: none;
      box-shadow: 0 1px white;
    }

    pre[data-line] .line-highlight[data-end]:after {
      content: attr(data-end);
      top: auto;
      bottom: .4em;
    }

    html body {
      font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
      font-size: 16px;
      line-height: 1.6;
      color: #333;
      background-color: #fff;
      overflow: initial;
      box-sizing: border-box;
      word-wrap: break-word
    }

    html body>:first-child {
      margin-top: 0
    }

    html body h1,
    html body h2,
    html body h3,
    html body h4,
    html body h5,
    html body h6 {
      line-height: 1.2;
      margin-top: 1em;
      margin-bottom: 16px;
      color: #000
    }

    html body h1 {
      font-size: 2.25em;
      font-weight: 300;
      padding-bottom: .3em
    }

    html body h2 {
      font-size: 1.75em;
      font-weight: 400;
      padding-bottom: .3em
    }

    html body h3 {
      font-size: 1.5em;
      font-weight: 500
    }

    html body h4 {
      font-size: 1.25em;
      font-weight: 600
    }

    html body h5 {
      font-size: 1.1em;
      font-weight: 600
    }

    html body h6 {
      font-size: 1em;
      font-weight: 600
    }

    html body h1,
    html body h2,
    html body h3,
    html body h4,
    html body h5 {
      font-weight: 600
    }

    html body h5 {
      font-size: 1em
    }

    html body h6 {
      color: #5c5c5c
    }

    html body strong {
      color: #000
    }

    html body del {
      color: #5c5c5c
    }

    html body a:not([href]) {
      color: inherit;
      text-decoration: none
    }

    html body a {
      color: #08c;
      text-decoration: none
    }

    html body a:hover {
      color: #00a3f5;
      text-decoration: none
    }

    html body img {
      max-width: 100%
    }

    html body>p {
      margin-top: 0;
      margin-bottom: 16px;
      word-wrap: break-word
    }

    html body>ul,
    html body>ol {
      margin-bottom: 16px
    }

    html body ul,
    html body ol {
      padding-left: 2em
    }

    html body ul.no-list,
    html body ol.no-list {
      padding: 0;
      list-style-type: none
    }

    html body ul ul,
    html body ul ol,
    html body ol ol,
    html body ol ul {
      margin-top: 0;
      margin-bottom: 0
    }

    html body li {
      margin-bottom: 0
    }

    html body li.task-list-item {
      list-style: none
    }

    html body li>p {
      margin-top: 0;
      margin-bottom: 0
    }

    html body .task-list-item-checkbox {
      margin: 0 .2em .25em -1.8em;
      vertical-align: middle
    }

    html body .task-list-item-checkbox:hover {
      cursor: pointer
    }

    html body blockquote {
      margin: 16px 0;
      font-size: inherit;
      padding: 0 15px;
      color: #5c5c5c;
      background-color: #f0f0f0;
      border-left: 4px solid #d6d6d6
    }

    html body blockquote>:first-child {
      margin-top: 0
    }

    html body blockquote>:last-child {
      margin-bottom: 0
    }

    html body hr {
      height: 4px;
      margin: 32px 0;
      background-color: #d6d6d6;
      border: 0 none
    }

    html body table {
      margin: 10px 0 15px 0;
      border-collapse: collapse;
      border-spacing: 0;
      display: block;
      width: 100%;
      overflow: auto;
      word-break: normal;
      word-break: keep-all
    }

    html body table th {
      font-weight: bold;
      color: #000
    }

    html body table td,
    html body table th {
      border: 1px solid #d6d6d6;
      padding: 6px 13px
    }

    html body dl {
      padding: 0
    }

    html body dl dt {
      padding: 0;
      margin-top: 16px;
      font-size: 1em;
      font-style: italic;
      font-weight: bold
    }

    html body dl dd {
      padding: 0 16px;
      margin-bottom: 16px
    }

    html body code {
      font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;
      font-size: .85em !important;
      color: #000;
      background-color: #f0f0f0;
      border-radius: 3px;
      padding: .2em 0
    }

    html body code::before,
    html body code::after {
      letter-spacing: -0.2em;
      content: "\00a0"
    }

    html body pre>code {
      padding: 0;
      margin: 0;
      font-size: .85em !important;
      word-break: normal;
      white-space: pre;
      background: transparent;
      border: 0
    }

    html body .highlight {
      margin-bottom: 16px
    }

    html body .highlight pre,
    html body pre {
      padding: 1em;
      overflow: auto;
      font-size: .85em !important;
      line-height: 1.45;
      border: #d6d6d6;
      border-radius: 3px
    }

    html body .highlight pre {
      margin-bottom: 0;
      word-break: normal
    }

    html body pre code,
    html body pre tt {
      display: inline;
      max-width: initial;
      padding: 0;
      margin: 0;
      overflow: initial;
      line-height: inherit;
      word-wrap: normal;
      background-color: transparent;
      border: 0
    }

    html body pre code:before,
    html body pre tt:before,
    html body pre code:after,
    html body pre tt:after {
      content: normal
    }

    html body p,
    html body blockquote,
    html body ul,
    html body ol,
    html body dl,
    html body pre {
      margin-top: 0;
      margin-bottom: 16px
    }

    html body kbd {
      color: #000;
      border: 1px solid #d6d6d6;
      border-bottom: 2px solid #c7c7c7;
      padding: 2px 4px;
      background-color: #f0f0f0;
      border-radius: 3px
    }

    @media print {
      html body {
        background-color: #fff
      }

      html body h1,
      html body h2,
      html body h3,
      html body h4,
      html body h5,
      html body h6 {
        color: #000;
        page-break-after: avoid
      }

      html body blockquote {
        color: #5c5c5c
      }

      html body pre {
        page-break-inside: avoid
      }

      html body table {
        display: table
      }

      html body img {
        display: block;
        max-width: 100%;
        max-height: 100%
      }

      html body pre,
      html body code {
        word-wrap: break-word;
        white-space: pre
      }
    }

    .document {
      width: 100%;
      height: 100%;
      box-sizing: border-box
    }

    .document .pagebreak,
    .document .newpage {
      page-break-before: always
    }

    .document pre.line-numbers {
      position: relative;
      padding-left: 3.8em;
      counter-reset: linenumber
    }

    .document pre.line-numbers>code {
      position: relative
    }

    .document pre.line-numbers .line-numbers-rows {
      position: absolute;
      pointer-events: none;
      top: 1em;
      font-size: 100%;
      left: 0;
      width: 3em;
      letter-spacing: -1px;
      border-right: 1px solid #999;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none
    }

    .document pre.line-numbers .line-numbers-rows>span {
      pointer-events: none;
      display: block;
      counter-increment: linenumber
    }

    .document pre.line-numbers .line-numbers-rows>span:before {
      content: counter(linenumber);
      color: #999;
      display: block;
      padding-right: .8em;
      text-align: right
    }

    .document .mathjax-exps .MathJax_Display {
      text-align: center !important
    }

    .document:not([for="preview"]) .code-chunk .btn-group {
      display: none
    }

    .document:not([for="preview"]) .code-chunk .status {
      display: none
    }

    .document:not([for="preview"]) .code-chunk .output-div {
      margin-bottom: 16px
    }

    .scrollbar-style::-webkit-scrollbar {
      width: 8px
    }

    .scrollbar-style::-webkit-scrollbar-track {
      border-radius: 10px;
      background-color: transparent
    }

    .scrollbar-style::-webkit-scrollbar-thumb {
      border-radius: 5px;
      background-color: rgba(150, 150, 150, 0.66);
      border: 4px solid rgba(150, 150, 150, 0.66);
      background-clip: content-box
    }

    html body[for="presentation"]:not([data-presentation-mode]) {
      position: relative;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      margin: 0;
      padding: 0;
      overflow: auto
    }

    html body[for="presentation"]:not([data-presentation-mode]) .document {
      position: relative;
      top: 0
    }

    @media screen and (min-width:914px) {
      html body[for="presentation"]:not([data-presentation-mode]) .document {
        padding: 2em calc(50% - 457px + 2em)
      }
    }

    @media screen and (max-width:914px) {
      html body[for="presentation"]:not([data-presentation-mode]) .document {
        padding: 2em
      }
    }

    @media screen and (max-width:450px) {
      html body[for="presentation"]:not([data-presentation-mode]) .document {
        font-size: 14px !important;
        padding: 1em
      }
    }

    @media print {
      html body[for="presentation"]:not([data-presentation-mode]) #sidebar-toc-btn {
        display: none
      }
    }

    html body[for="presentation"]:not([data-presentation-mode]) #sidebar-toc-btn {
      position: fixed;
      bottom: 8px;
      left: 8px;
      font-size: 28px;
      cursor: pointer;
      color: inherit;
      z-index: 99;
      width: 32px;
      text-align: center;
      opacity: .4
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn {
      opacity: 1
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc {
      position: fixed;
      top: 0;
      left: 0;
      width: 300px;
      height: 100%;
      padding: 32px 0 48px 0;
      font-size: 14px;
      box-shadow: 0 0 4px rgba(150, 150, 150, 0.33);
      box-sizing: border-box;
      overflow: auto;
      background-color: inherit
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar {
      width: 8px
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track {
      border-radius: 10px;
      background-color: transparent
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb {
      border-radius: 5px;
      background-color: rgba(150, 150, 150, 0.66);
      border: 4px solid rgba(150, 150, 150, 0.66);
      background-clip: content-box
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a {
      text-decoration: none
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul {
      padding: 0 1.6em;
      margin-top: .8em
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li {
      margin-bottom: .8em
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul {
      list-style-type: none
    }

    html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .document {
      left: 300px;
      width: calc(100% - 300px);
      padding: 2em calc(50% - 457px - 150px);
      margin: 0;
      box-sizing: border-box
    }

    @media screen and (max-width:1274px) {
      html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .document {
        padding: 2em
      }
    }

    @media screen and (max-width:450px) {
      html body[for="presentation"]:not([data-presentation-mode])[html-show-sidebar-toc] .document {
        width: 100%
      }
    }

    html body[for="presentation"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .document {
      left: 50%;
      transform: translateX(-50%)
    }

    html body[for="presentation"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc {
      display: none
    }

    /* Please visit the URL below for more information: */
    /*   https://shd101wyy.github.io/document-enhanced/#/customize-css */
    .document.document .center {
      width: auto;
      display: table;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
</head>

<body for="presentation">
  <div class="mume document  ">

    <!--Heimu from moegirlpedia-->
    <style>
      .lumia,
      .lumia a,
      a .lumia,
      .lumia a.new {
        background-color: #252525;
        color: #252525;
        text-shadow: none;
      }

      .lumia:hover,
      .lumia:active,
      .lumia:hover .lumia,
      .lumia:active .lumia {
        color: rgba(230, 231, 234, 0.848) !important;
      }

      .lumia:hover a,
      a:hover .lumia,
      .lumia:active a,
      a:active .lumia {
        color: rgba(173, 216, 230, 0.887) !important;
      }

      .lumia:hover .new,
      .lumia .new:hover,
      .new:hover .lumia,
      .lumia:active .new,
      .lumia .new:active,
      .new:active .lumia {
        color: #BA0000 !important;
      }

      table {
        display: block;
        overflow-x: scroll;
      }
    </style>

    <div style="width: 100%; min-width: 430px; max-width:800px">
      <blockquote>
        <p>2022-10-31 MON</p>
      </blockquote>
      <h1 id="h1">C语言指针指北</h1>
      <table>
        <tbody>
          <tr>
            <td width="80"> <a href="https://gitee.com/Tomnycui"><img id="i0"
                  src="./Brief introdunction to pointers_files/Knock.png"></a> </td>
            <td style="word-break:break-all"> <i>阅读本文，你将得到： <bk>
                  对<b>内存</b>、<b>指针</b>、<b>字符串</b>、<b>函数调用和参数传递</b>、<b>文件操作</b> 的深刻理解。</bk></i> </td>
          </tr>
        </tbody>
      </table>
      <table style="max-width:800px">
        <tbody>
          <tr>
            <td width="300">
              <table>
                <tbody>
                  <tr>
                    <td colspan="2"><b>
                        <div align="center">C语言指针指北：目录</div>
                      </b></td>
                  </tr>
                  <tr>
                    <td width="60"><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#h1"><img
                          src="./Brief introdunction to pointers_files/Knock.png"></a></td>
                    <td>启：启之秘术之启</td>
                  </tr>
                  <tr>
                    <td><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#cp1"><img
                          src="./Brief introdunction to pointers_files/The_Byzantine_Tinct.png"></a></td>
                    <td style="word-break:break-all">第一节：<br>(静态)内存模型的引入</td>
                  </tr>
                  <tr>
                    <td><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#cp2"><img
                          src="./Brief introdunction to pointers_files/Geminiadfucine.png"></a></td>
                    <td>第二节(上)：<br>指针！指针！</td>
                  </tr>
                  <tr>
                    <td><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#cp2s1"><img
                          src="./Brief introdunction to pointers_files/Influenceknockg.png"></a></td>
                    <td>第二节(下)：<br>指针：觉醒</td>
                  </tr>
                  <tr>
                    <td><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#cp3"><img
                          src="./Brief introdunction to pointers_files/Manualdeparturevak.png"></a></td>
                    <td>第三节：<br>指针、数组、字符串</td>
                  </tr>
                  <tr>
                    <td><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#cp4"><img
                          src="./Brief introdunction to pointers_files/Azoth.png"></a></td>
                    <td>第四节：<br>动态内存管理</td>
                  </tr>
                  <tr>
                    <td><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#cp5"><img
                          src="./Brief introdunction to pointers_files/Consecrated_Lintel.png"></a></td>
                    <td>第五节：<br>地址的传递</td>
                  </tr>
                  <tr>
                    <td><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#cp6"><img
                          src="./Brief introdunction to pointers_files/Frangiclave.png"></a></td>
                    <td>第六节：<br>函数指针与高阶函数初步</td>
                  </tr>
                  <tr>
                    <td><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#cp7"><img
                          src="./Brief introdunction to pointers_files/Port_Noon.png"></a></td>
                    <td>序章：<br>结束与开始</td>
                  </tr>
                </tbody>
              </table>
            </td>
            <td>
              <div align="center" style="line-break: anywhere;"><small><i>点击标题图标可跳转到指定位置</i></small></div>
              <img src="./Brief introdunction to pointers_files/The_Unnumbered_Stones4x.png">
              <br>
              <blockquote align="center">
                <p>Each hour has its colour.<br>Each flame has its fuel.<br>Dream furiously.</p>
              </blockquote>
            </td>
          </tr>
        </tbody>
      </table>
      <h2 id="cp1">第一节：(静态)内存模型的引入</h2>
      <table>
        <tbody>
          <tr>
            <td width="80px"><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#h1"><img id="i1"
                  src="./Brief introdunction to pointers_files/The_Byzantine_Tinct.png"></a> </td>
            <td style="word-break:break-all"> <i>C是<b>直接操作机器</b>的语言之一。因此，在讨论主要用于直接操作内存的指针前，需要先介绍静态的内存模型。</i> </td>
          </tr>
        </tbody>
      </table>
      <h3>什么是内存模型？</h3>
      <p>内存模型是一个抽象概念，用于描述特定的内存组织方式。C作为一种成熟的底层语言，具有最接近于物理内存组织方式的内存模型。</p>
      <h3>什么是 C 的（静态）内存模型？</h3>
      <p>引用一段 <code>cppreference.com</code> 的解释：</p>
      <blockquote>
        <p><strong>Memory model</strong><br>
          The data storage (memory) available to a C program is <em>one or more contiguous sequences of&nbsp;bytes</em>.
          Each byte in memory has a unique&nbsp;address.<br>
          <strong>Bytes</strong><br>
          A&nbsp;byte&nbsp;is the smallest addressable unit of memory. It is defined as a contiguous sequence of bits. C
          supports bytes of (normally) sizes 8 bits and greater.
        </p>
      </blockquote>
      <p align="right"><a href="https://en.cppreference.com/w/c/language/memory_model">from C Memory Model</a></p>
      <p>
        <font color="DeepPink"><b>TL;DR</b></font><br>
        简单来说，C语境下的<ruby>内存<rt>memory</rt></ruby>被看成是一段连续的由<ruby>字节<rt>byte(s)</rt></ruby>组成的序列。其中 一般情况下一个字节相当于八个<ruby>比特
          <rt>bit(s)</rt></ruby>（<code>bit(s)</code>又译作“位”），每个字节都具有独一无二的<ruby>地址<rt>address</rt></ruby>，且是<ruby>连续<rt>
            正整数集内</rt></ruby>的。<br>
        抽象一下，我们得到了<b><ruby>字节<rt>byte</rt></ruby>的概念</b>：
      </p>
      <ul>
        <li>字节是可访问的最小<ruby>内存单位<rt>memory unit</rt></ruby>；</li>
        <li>字节的<ruby>地址<rt>address</rt></ruby>具有唯一性；</li>
        <li>字节的<ruby>地址<rt>address</rt></ruby>具有<ruby>后继性<rt>在整数集内的</rt></ruby>；<span class="lumia">
            <details>
              <summary>解释：「后继性」</summary>
              <blockquote>
                <p>「后继性」指一个元素有其「后继者」的性质。<br>例如：<code>0</code> 的后继是 <code>1</code>，<code>1</code> 的后继是
                  <code>2</code>，……<br><i>由于这条性质来自于自然数，因此不妨看看其来源：<a
                      href="https://encyclopediaofmath.org/wiki/Peano_axioms">Encyclopedia of Math: Peano_axioms</a></i>
                </p>
              </blockquote>
            </details>
          </span></li>
      </ul>
      <p>
        <font color="#71AEE2"><b>就这？</b></font><br>
        <font color="#AC6E46"><b>就这。这已经是完整的（静态）内存模型的概念了。</b></font><br>
        <font color="#71AEE2"><b>为什么强调“静态”？</b></font><br>
        <font color="#AC6E46"><b>因为只介绍了<ruby>内存位置<rt>memory location</rt></ruby>而没有提及<ruby>内存顺序<rt>memory order</rt>
              </ruby>，后者是多线程下的问题，希望你永远不会遇到。</b></font><br>
        <font color="71AEE2"><b>所以介绍这个到底有什么用呢？<ruby>（半恼）<rt><i>赫尔墨特有急躁</i></rt></ruby></b></font>
      </p>
      <p><em>注：以下所有内容均在 C 的内存模型中进行讨论。</em></p>
      <h2 id="cp2">第二节：指针！指针！</h2>
      <table>
        <tbody>
          <tr>
            <td width="80"><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#h1"><img id="i2"
                  src="./Brief introdunction to pointers_files/Geminiadfucine.png"></a> </td>
            <td> <i>The Pointers permits no seal and no isolation. It thrusts us gleefully out of the safety of
                ignorance.</i> </td>
          </tr>
        </tbody>
      </table>
      <p>如上文所说，C作为强大的底层语言，具有直接操作硬件<small><span class="lumia">（尤其是内存）</span></small>的能力，这种能力的体现就是指针。<br>
        一切在内存上的数据<small><span class="lumia">（包括系统和其他程序的数据和本体）</span></small>都在指针的操作范围内。<small><span
            class="lumia">（一个著名的例子是 Cheat Engine 的内存修改）</span></small></p>
      <p>
        <font color="Gold"><b>[WARNING: ]</b></font><b> 接下来所提到的所有指针均指「<ruby>变量指针<rt>Pointer of Varible</rt>
            </ruby>」并且简称为「指针」。对于「<ruby>函数指针<rt>Function Pointer</rt></ruby>」，我们将在最后一节提及。</b>
      </p>
      <blockquote>
        <p>现在介绍函数指针还为时过早，我们不妨放到最后谈，在此之前如无特别注明，所有提及的指针都是变量指针，下面不引起混淆时简称指针。</p>
      </blockquote>
      <p>首先先给出<ruby>变量指针<rt>Pointer of Varible</rt></ruby>的完整定义：</p>
      <ul>
        <li>指针是一种整型变量，在64位系统上，指针等同于 <code>unsigned long long</code> ，大小为8 <code>byte</code>。</li>
        <li>因为所有的变量指针都是 <code>unsigned long long</code>， 因此指针没有严格意义上的类型。</li>
        <li><small>（接上条）</small><strong>通常意义下指针的所谓 “类型” 实际上是一个编译器标签。我们沿用 “类型” 这个称呼。</strong></li>
        <li><small>（接上条）</small>因为所有<ruby>指针<rt>变量指针</rt></ruby>都被规定为相同的内存布局，因此它们之间可以相互转换。</li>
        <li>一般情况下，指针储存的值以“<ruby>地址<rt>address</rt></ruby>”的语义进行解释。</li>
      </ul>
      <p>
        <font color="DeepPink"><b>THUS</b></font><br>
        也就是说，指针不过是一种特殊变量，内部储存的还是整数，因此本质上指针也是一种整数变量——只不过它们所储存的整数具有「地址」的意义。
      </p>
      <p>指针的工作原理源于内存模型。内存上的每个字节都有且仅有唯一确定的地址，因此要确定一个变量，只需要三个信息：</p>
      <ol>
        <li>该变量在内存上的位置；</li>
        <li>该变量所占据内存的长度（占了多少字节）；</li>
        <li>如何解释该变量。</li>
      </ol>
      <p>其中第一条指的就是该变量的地址，而第二条和第三条指的就是该变量的类型——因为类型同时提供了「长度」和「如何处理」两个信息。</p>
      <blockquote>
        <p>举个简单的例子，对于 <code>int</code> 类型，长度是 <code>4bytes</code>，处理方式是「按四字节长度的整数的处理方式处理」；对于 <code>double</code> 类型，长度是
          <code>8bytes</code>，处理方式是「按双精度浮点数的处理方式处理」。</p>
      </blockquote>
      <p>因此指针被设计成同时处理这两种信息的载体：</p>
      <ul>
        <li>对于内存位置，根据字节地址的唯一确定性，<strong>储存「变量所占据的第一个字节的地址」</strong>。</li>
        <li>对于长度和解释方式，在编译期处理——也就是前面提到的，使用形式上的“类型”来进行处理。<br>
          指针的“类型”和指针变量本身无关，而是用于解释被指向的内存区域——至于那块区域是否真的存在这样同类型的一个变量，实际上无法检查。<span
            class="lumia">因为「类型」这个概念本身就只存在于编译期。</span></li>
      </ul>
      <p>这三个信息，也就是一个指针，足以用于控制任意内存区域——以任意方式。<br>
        我们可以这样声明指针：</p>
      <pre data-role="codeBlock" data-info="cpp" class="language-cpp"><span class="token operator">&lt;</span>type<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token operator">&lt;</span>pointer_name<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token operator">&lt;</span>init_value<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre>
      <p>请原谅我使用这样严肃死板的写法，接下来是一些解释：</p>
      <ul>
        <li><code>&lt;type&gt;</code> 是任意类型——你可以使用任何类型替代它，例如用 <code>int</code>；</li>
        <li><code>&lt;pointer_name&gt;</code> 是将要被声明的指针的名字——这里用 <code>p</code> 来替代它；</li>
        <li><code>&lt;init_value&gt;</code> 是初始化这个指针用的值。这不是必需的，但是建议使用 <code>NULL</code> 来进行初始化。</li>
      </ul>
      <p>于是我们得到了这样的一行代码：<code>int *p = NULL;</code> 声明了名为 <code>p</code> 的指针，将以 <code>int</code>
        的解释方式解释它所指向的内存区域，并且初始化——将它指向一个安全的、没有任何内容的、保留的地址：<code>NULL</code>。</p>
      <blockquote>
        <p><code>NULL</code> 是一个常量，代表一个安全的内存地址，以避免出现「野指针」——一种没有进行初始化的指针，指向随机的位置。<br>
          用 <code>0</code> 或者 <code>nullptr</code> 替代 <code>NULL</code> 一般情况下都是允许的，但不提倡使用前者<span class="lumia">（尽管一般情况下
            <code class="lumia">NULL</code> 的值实际上就是 <code
              class="lumia">0</code>，但这是由操作系统决定的）</span>，而后者是C++的关键字，不能在纯C下使用。</p>
      </blockquote>
      <p>现在我们有指针了。</p>
      <h3 id="cp2s1">指针：觉醒</h3>
      <table>
        <tbody>
          <tr>
            <td width="80"><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#h1"><img id="i1"
                  src="./Brief introdunction to pointers_files/Influenceknockg.png"></a> </td>
            <td> <i>There is a Door that should not open, and even now its hinges are roused...... </i> </td>
          </tr>
        </tbody>
      </table>
      <h4>指针最基础的运用：储存地址</h4>
      <p>很显然，一个只储存了 <code>NULL</code>
        这个啥用没有只能占位的地址的指针是干不出什么有用的事的，所以我们还得想办法搞几个变量的地址——十分方便地，C给我们提供了这样一个运算符：<code>&amp;</code>，它的名字就叫<ruby>寻址算符<rt>
            Addressing Operator</rt></ruby>。<br>
        用法是这样的：<code>&amp;&lt;varible&gt;;</code> 假设对变量 <code>int a = 123;</code> 使用这个算符：<code>&amp;a;</code>
        然后我们将得到一个值：<code>(&amp;a)</code>，这是一个整数值：<code>a</code>在内存中的「绝对地址」。<br>
        很自然的，可以把这个地址存在指针里：</p>
      <pre data-role="codeBlock" data-info="cpp" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token operator">*</span>p_int <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token keyword keyword-float">float</span> <span class="token operator">*</span>p_float <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token keyword keyword-short">short</span> <span class="token operator">*</span>p_short <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
</pre>
      <p>
        <font color="#71AEE2"><b>等等，你怎么整了三个指针，还是不同类型的？</b></font><br>
        <font color="#AC6E46"><b>因为类型对指针储存的地址没有意义，所以都一样，都可以存。</b></font><br>
        <font color="#71AEE2"><b>但是指针的“类型”，不是会影响什么“解释方式”吗？那到底是什么？</b></font><br>
        <font color="#AC6E46"><b>好问题！这就是接下来会谈到的部分。</b></font>
      </p>
      <p>现在我们不但有指针，也获得了 <code>int</code> 类型的变量 <code>a</code> 的地址，已经具有充足的条件来操作 <code>a</code> 了。</p>
      <h4>指针最基础的运用：间接访问</h4>
      <p>因此我们引入第二个要介绍的新算符：<code>*</code>， 名字叫<b><ruby>间接访问算符<rt>Indirection Operator</rt>
            </ruby></b>，简称「<strong>间接算符</strong>」。<br>
        这个算符只能用于指针，用法是这样的：<code>*&lt;pointer&gt;;</code> 。以上面的 <code>p_int</code>
        为例子，使用这个算符：<code>*p_int;</code>，我们可以得到一个<strong>引用</strong>：<code>(*p_int)</code>，这个引用与 <code>a</code> 完全等价。</p>
      <p>
        <font color="#71AEE2"><b>等等，等等，等等……<span style="font-size: 0.6cm">引用</span>？什么鬼什么鬼什么鬼<span
              style="font-size: 0.5cm">？<span style="font-size: 0.6cm">？<span
                  style="font-size: 0.7cm">？</span></span></span></b></font><br>
        <font color="#AC6E46"><b>别急，别急，我知道这听起来有点突兀，但是我们不妨看看下面的例子。</b></font>
      </p>
      <table>
        <tbody>
          <tr>
            <td colspan="2"><span style="font-size: 0.6cm">两种表达完全等价的例子：</span></td>
          </tr>
          <tr>
            <td>
              <table>
                <thead>
                  <tr>
                    <th>表达1</th>
                    <th>表达2</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <div style="width: 2cm"><code>a = 5;</code></div>
                    </td>
                    <td>
                      <div style="width: 3.6cm"><code>(*p_int) = 5;</code></div>
                    </td>
                  </tr>
                  <tr>
                    <td><code>a += 3;</code></td>
                    <td><code>(*p_int) += 3;</code></td>
                  </tr>
                  <tr>
                    <td><code>++a;</code></td>
                    <td><code>++(*p_int);</code></td>
                  </tr>
                </tbody>
              </table>
            </td>
            <td>
              <table>
                <tbody>
                  <tr>
                    <td>
                      <span style="font-size: 0.45cm">注：</span>
                      <div style="width: 4cm">
                        在<br><span><code>int a = 123;</code><br><code>int *p_int = &amp;a;</code></span><br>的前提下。</div>
                    </td>
                  </tr>
                </tbody>
              </table>
            </td>
          </tr>
        </tbody>
      </table>
      <p>
        <font color="#71AEE2"><b>我想我理解「完全等价」了：<code>(*p_int)</code> 成为了 <code>a</code> 的一个功能完整的「替身」，所有对
            <code>(*p_int)</code> 的操作实际上都会落到 <code>a</code> 上——这仅仅是因为 <code>p_int</code> 持有 <code>a</code>
            的地址吗？<code>p_int</code> 是怎么知道 <code>a</code> 的类型的呢？<small><span class="lumia">（换言之，编译器怎么知道要用处理<code
                  class="lumia">int</code>的方式处理<code class="lumia">a</code>呢？）</span></small></b></font><br>
        <font color="#AC6E46"><b>事实上，它根本就不知道。</b></font>
      </p>
      <p>当我们获取 <code>a</code> 的地址的时候，实际上我们只获取了 <code>a</code>
        的地址，而丢失了所有其他能使它成为变量的信息：包括它的<strong>名字</strong>和<strong>类型</strong>，<small><span
            class="lumia">（「类型」包括了「大小（长度）」和「解释方式」两种信息）</span></small> 在只知道地址的情况下，我们是无法正确使用这块属于 <code>a</code>
        的内存区域的。<br>
        但是我们可以指定如何解释它——使用指针的「类型」。<span class="lumia"><s>如果忘了，不妨翻翻前面的内容先复习一下。</s></span><br>
        上面的例子中，使用的是定义为：<code>int *p;</code> 的指针，因此使用 <code>*p</code> 时，其整体的类型是 <code>int</code>。<br>
        同理，定义为：<code>float *p;</code> 的指针，使用 <code>*p</code> 时，其整体的类型是 <code>float</code>；<br>
        定义为：<code>short *p;</code> 的指针，使用 <code>*p</code> 时，其整体的类型是 <code>short</code>。</p>
      <p>
        <font color="#71AEE2"><b>但是 <code>float</code> 和 <code>int</code> 根本就是两套解释方法啊？</b></font><br>
        <font color="#AC6E46"><b>不管，只要是对 <code>float</code> 指针使用 <code>&amp;</code> 得到的，就按 <code>float</code> 来解释。</b>
        </font>
      </p>
      <p>
        <font color="#71AEE2"><b>但是 <code>short</code> 长度上比 <code>int</code> 短了一半啊？</b></font><br>
        <font color="#AC6E46"><b>因此被以 <code>short</code> 的形式使用的也只有 <code>int</code> 中最低位的两个字节。</b></font>
      </p>
      <p>
        <font color="#71AEE2"><b>那如果使用的是比 <code>int</code> 还长的 <code>long long</code> 呢？</b></font><br>
        <font color="#AC6E46"><b>不管，直接从地址确定的那个 <code>byte</code> 开始数，数够8个<small><span class="lumia">（<code
                  class="lumia">long long</code> 长度为 <code class="lumia">8bytes</code>）</span></small>，当
            <code>long long</code> 用。</b></font>
      </p>
      <p>
        <font color="#71AEE2"><b>所以无论是什么类型的指针，间接访问的时候都是直接按地址找第一个字节，然后数够足够的字节吗？</b></font><br>
        <font color="#AC6E46"><b>正是如此。</b></font>
      </p>
      <details>
        <summary>知识扩充：「为什么要用 <code>NULL</code> 初始化指针？」</summary>
        <blockquote>
          由于指针储存的值被当作地址解释，因此对指针「间接访问」时，操作会落实到对应的内存上。在没有初始化的时候，指针一开始指向的地址是不可预知的——可能是操作系统中的某个关键数据中的一部分——在这个位置写入新的值会导致操作系统崩溃。而
          <code>NULL</code> 是一个约定俗成的位置，操作系统会保证对这个位置的任何操作都是无效的——例如间接访问 <code>NULL</code> 指向的内存<span
            class="lumia">（0号位置）</span>不会崩溃系统，但会崩溃你的程序。 </blockquote>
      </details>
      <details>
        <summary>知识扩充：所以到底什么是引用？</summary>
        <blockquote>
          <font color="#71AEE2"><b>可是即便如此，我还是不知道「引用」是什么意思。</b></font><br>
          <font color="#AC6E46"><b>这得回归到一个基本问题：你想想，我们是怎么使用变量`a`的？</b></font><br>
          <font color="#71AEE2"><b>蛤？这不是<span style="font-size: 0.5cm">直接使用</span>吗？</b></font><br>
          <font color="#AC6E46"><b>没错，这是因为 `a` 有名字：`a`，这是它的符号，它的名字，我们用 `a` 来表示它，来表示内存上的一段区域，来表达这个概念：一个变量，并且是 `int`
              类型的。</b></font><br>
          <font color="#71AEE2"><b>难道还有没有名字的变量吗？</b></font><br>
          <font color="#AC6E46"><b>正是如此。</b></font><br>
          有一些变量本身，确实存在于内存之中，但是没有名字——因为它们并不是在编译期产生的，而是在运行期产生的——因此不能通过名字被直接使用。<br>
          但他们是可以被使用的！<br>
          只要知道它们的类型和地址，只需要声明一个对应的指针来指向这个地址，就可以间接访问它们的本体——这也是「间接访问运算符」的名称来源。<br>
          <font color="#71AEE2"><b>所以变量名本身，也是一个引用？</b></font><br>
          <font color="#AC6E46"><b>这不是严谨的，但是确实可以这样理解。</b></font><br>
          <font color="#71AEE2"><b>但是既然运算结果是引用，为什么这个算符还叫「解除引用」？</b></font><br>
          <font color="#AC6E46"><b>额……这是历史问题，事实上，叫<span style="font-size: 0.6cm">「间接访问运算符」</span>更准确。</b></font><br>
          <font color="#71AEE2"><b>原来如此……</b></font>
        </blockquote>
      </details>
      <details>
        <summary>知识扩充：「解除引用算符」</summary>
        <blockquote><ruby>解除引用算符<rt>Dereference Operator</rt></ruby>实际上就是<ruby>间接访问算符<rt>Indirection Operator</rt>
            </ruby>，这实际上是一个历史问题。国内对「解除引用」的翻译往往各有千秋，甚至违反直觉，阻碍理解<span class="lumia">（因为C++中「引用」有特殊含义）</span>，因此这里不采用这个名称。
        </blockquote>
      </details>
      <h4>总结：</h4>
      <p>对于任意变量（包括指针），都具有以下操作：</p>
      <table>
        <thead>
          <tr>
            <th>操作</th>
            <th>语法</th>
            <th>例子的返回值</th>
            <th>例子</th>
            <th>说明</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>寻址</td>
            <td>
              <div style="width: 3cm"><code>&amp;&lt;varible&gt;</code></div>
            </td>
            <td>
              <div style="width: 4.8cm"><code>address of &lt;varible&gt;</code></div>
            </td>
            <td>
              <div style="width: 5.5cm"><code>&amp;a;</code><br> where <code>a</code> is an <code>int</code></div>
            </td>
            <td>
              <div style="width: 4.3cm">获得 <code>a</code> 的内存地址，一般是一个<code>unsigned long long</code>类型的值</div>
            </td>
          </tr>
        </tbody>
      </table>
      <p>对于指针，有如下操作：</p>
      <table>
        <thead>
          <tr>
            <th>操作</th>
            <th>语法</th>
            <th>例子</th>
            <th>说明</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>声明</td>
            <td>
              <div style="width: 9cm"><code>&lt;type&gt; *&lt;pointer_name&gt; = &lt;init_value&gt;;</code></div>
            </td>
            <td>
              <div style="width: 5cm"><code>int *p = 0x26fa7139;</code></div>
            </td>
            <td>
              <div style="width: 10cm">声明变量 <code>p</code> 为对 <code>int</code> 型的指针，以十六进制值 <code>0x26fa7139</code> 初始化
              </div>
            </td>
          </tr>
          <tr>
            <td>赋值</td>
            <td><code>&lt;pointer&gt; = &lt;address&gt;;</code></td>
            <td><code>p = nullptr;</code></td>
            <td>
              <div style="width: 10cm">给 <code>p</code> 赋常量 <code>nullptr</code></div>
            </td>
          </tr>
          <tr>
            <td>
              <div style="width: 1cm">间接访问</div>
            </td>
            <td><code>*&lt;pointer&gt;;</code></td>
            <td><code>*p</code></td>
            <td>间接访问 <code>p</code> 指向的内存区域 <code>(*p)</code>整体恢复变量名同等地位。</td>
          </tr>
          <tr>
            <td>前递增</td>
            <td><code>++&lt;pointer&gt;;</code></td>
            <td><code>++p</code></td>
            <td>
              <div style="width: 10cm"><code>p</code> 所指位置后移 <code>sizeof(&lt;type&gt;)</code> 个 <code>byte</code></div>
            </td>
          </tr>
          <tr>
            <td>后递增</td>
            <td><code>&lt;pointer&gt;++;</code></td>
            <td><code>p++</code></td>
            <td>同上</td>
          </tr>
          <tr>
            <td>前递减</td>
            <td><code>--&lt;pointer&gt;;</code></td>
            <td><code>--p</code></td>
            <td>
              <div style="width: 10cm"><code>p</code> 所指位置前移 <code>sizeof(&lt;type&gt;)</code> 个 <code>byte</code></div>
            </td>
          </tr>
          <tr>
            <td>后递减</td>
            <td><code>&lt;pointer&gt;--;</code></td>
            <td><code>p--</code></td>
            <td>同上</td>
          </tr>
          <tr>
            <td>数加法</td>
            <td><code>&lt;pointer&gt; + &lt;整数类型&gt;;</code></td>
            <td><code>p + 13</code></td>
            <td>
              <div style="width: 8cm">得到一个新指针，指向 <code>p</code> 所指位置后移 <code>13 * sizeof(&lt;type&gt;)</code> 个
                <code>byte</code></div>
            </td>
          </tr>
          <tr>
            <td>数减法</td>
            <td><code>&lt;pointer&gt; - &lt;整数类型&gt;;</code></td>
            <td><code>p - 42</code></td>
            <td>
              <div style="width: 8cm">得到一个新指针，指向 <code>p</code> 所指位置前移 <code>45 * sizeof(&lt;type&gt;)</code> 个
                <code>byte</code></div>
            </td>
          </tr>
          <tr>
            <td>减法</td>
            <td><code>&lt;pointer1&gt; - &lt;pointer2&gt;;</code></td>
            <td><code>p1 - p2</code> <br>where <code>p1</code> and <code>p2</code> are pointers of same type.</td>
            <td>
              <div style="width: 10cm"><code>p</code> 所指位置前移 <code>45 * sizeof(&lt;type&gt;)</code> 个 <code>byte</code>
              </div>
            </td>
          </tr>
          <tr>
            <td>赋值加法</td>
            <td><code>&lt;pointer&gt; += &lt;整数类型&gt;;</code></td>
            <td><code>p += 23</code></td>
            <td>
              <div style="width: 10cm"><code>p</code> 所指位置后移 <code>23 * sizeof(&lt;type&gt;)</code> 个 <code>byte</code>
              </div>
            </td>
          </tr>
          <tr>
            <td>赋值减法</td>
            <td><code>&lt;pointer&gt; -= &lt;整数类型&gt;;</code></td>
            <td><code>p -= 45</code></td>
            <td>
              <div style="width: 10cm"><code>p</code> 所指位置前移 <code>45 * sizeof(&lt;type&gt;)</code> 个 <code>byte</code>
              </div>
            </td>
          </tr>
        </tbody>
      </table>
      <p>注：<code>&lt;type&gt;</code> 为指针的“类型”。</p>
      <p>
        <font color="#71AEE2"><b>好多运算符……但是除了前三个，其他的是什么意思呢？</b></font><br>
        <font color="#AC6E46"><b>这就是我们下一节将要涉及的内容了。</b></font>
      </p>
      <h2 id="cp3"> 第三节：指针、数组、字符串 </h2>
      <table>
        <tbody>
          <tr>
            <td width="80"> <a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#h1"><img id="i0"
                  src="./Brief introdunction to pointers_files/Manualdeparturevak.png"></a> </td>
            <td> <i> The Wound and the Threshold and the Revelation are all the Gate's aspects, and here is their secret
                doctrine...</i> </td>
          </tr>
        </tbody>
      </table>
      <blockquote>
        <p>指针出现的初衷是为了操作任意内存上的数据，因此，用尽量少的指针变量控制和管理尽量大的内存区域，就成为了一个必须解决的问题。<br>
          不妨回顾一下内存模型：</p>
        <ol>
          <li>字节是可访问的最小内存单位；</li>
          <li>字节的地址具有唯一性；</li>
          <li>字节的地址具有在整数集内的后继性；</li>
        </ol>
        <p>其中，条件 (1) 已用于推出变量的本质；条件 (2) 建立了从地址到变量的映射关系<small><span class="lumia">（「寻址」和「间接访问」）</span></small>，而条件 (3)
          还没有被使用。</p>
      </blockquote>
      <p>从条件 (3) 我们可以推出：</p>
      <blockquote>
        <p><strong>3.1. 在已知一个地址 p 的条件下，p 减去一个不大于自身的正整数或加上一个任意大小的正整数后，得到的仍为合法的地址。</strong></p>
      </blockquote>
      <p>这个性质用在指针上，就得到了指针的一个功能（性质）：<strong>指针偏移</strong>。</p>
      <p>
        <font color="#71AEE2"><b>我明白了，前面的递增和递减运算符是用来计算指针偏移的！</b></font><br>
        <font color="#AC6E46"><b>是的。不仅如此，数加和数减也是用于计算指针偏移的。</b></font>
      </p>
      <p><strong>指针偏移本质上是地址的计算。</strong><br>
        为了说明这类操作可以怎么用，我们得先找一片连续的内存区域。在这里，选用数组的方式来实现。</p>
      <details>
        <summary>解释：「数组」</summary>
        <blockquote>
          <p><small>对于数组的认识，本来假定读者已经熟悉，但此处不妨作为一个复习。</small><br><b><ruby>数组<rt>Array</rt></ruby></b>是一种在内存中连续分配<span
              class="lumia">（占有连续的内存区域）</span>的、固定长度的数据结构。显然：一个储存 <code>&lt;type&gt;</code> 类型变量的长度为 <code>N</code>
            的数组占有内存大小为：<br><code>N * sizeof(&lt;type&gt;)</code></p>
        </blockquote>
      </details>
      <p></p>
      <p>先整一个数组：</p>
      <pre data-role="codeBlock" data-info="cpp" class="language-cpp"><span class="token keyword keyword-int">int</span> array<span class="token punctuation">[</span><span class="token number">114514</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre>
      <p>就这样我们获得了一个名为 <code>array</code> 的，长度为 <code>114514</code>，第 <code>0~6</code> 个元素已经指定<small><span
            class="lumia">（依次为1、9、1、9、8、1、0）</span></small>的数组。</p>
      <p>显然，我们可以取其中一个元素的地址出来看看：</p>
      <pre data-role="codeBlock" data-info="cpp" class="language-cpp"><span class="token comment">// 0 1 2 3 4 5 6 ......</span>
<span class="token comment">// 1 9 1 9 8 1 0 ......</span>
<span class="token comment">//     ↑Here</span>
<span class="token keyword keyword-int">int</span> <span class="token operator">*</span>needle <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
      <p>显然现在 <code>*needle</code> 是 <code>1</code>，<br>
        同时有：</p>
      <table>
        <thead>
          <tr>
            <th>表达式</th>
            <th>值</th>
            <th>表达式</th>
            <th>值</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>*(needle - 2)</code></td>
            <td><code>1</code></td>
            <td><code>*(needle + 2)</code></td>
            <td><code>8</code></td>
          </tr>
          <tr>
            <td><code>*(needle - 1)</code></td>
            <td><code>9</code></td>
            <td><code>*(needle + 3)</code></td>
            <td><code>1</code></td>
          </tr>
          <tr>
            <td><code>*(needle + 1)</code></td>
            <td><code>9</code></td>
            <td><code>*(needle + 4)</code></td>
            <td><code>0</code></td>
          </tr>
        </tbody>
      </table>
      <p>
        <font color="#71AEE2"><b>哇哦，这不是和那个方括号一样吗？</b></font><br>
        <font color="#AC6E46"><b>实际上，<code>operator[]</code> 本身就会展开，例如 <code>array[5]</code> 会展开成
            <code>*(array + 5)</code> 这种形式。</b></font><br>
        <font color="#71AEE2"><b>我开始理解为什么C的数组下标是从 <code>0</code> 开始的了……</b></font><br>
        <font color="#71AEE2"><b>慢着，你刚刚写的是 <code>*(array + 5)</code> 是吧？！！也就是说——<code>array</code> 也是指针？？？</b></font>
        <br>
        <font color="#AC6E46"><b>是的！<code>array</code> 指向的，就是数组的第一个元素。</b></font><br>
        <font color="#AC6E46"><b>不仅如此，指针加整数的运算，是具有交换性的——也就是说，<code>array + 2</code> 等价于 <code>2 + array</code>。</b>
        </font><br>
        <font color="#71AEE2"><b>你的意思是说……我可以将 <code>array[2]</code> 写成 <code>2[array]</code> 吗？！</b></font><br>
        <font color="#AC6E46"><b>完全可以。</b></font>
      </p>
      <p>
        <font color="Gold"><b>[WARNING: ]</b></font><b> 接下来开始提及的内容请务必认真注意。</b>
      </p>
      <p>注意到刚刚我们使用的数组下标是在定义范围内的。如果使用范围外的内存会发生什么？<small><span class="lumia">例如：数组下标越界、指针指向的地址是你不该动的……</span></small></p>
      <blockquote>
        <div align="center">「什么都不会发生。」</div>
        <div align="right">——这是可能的</div>
      </blockquote>
      <p>实际上，一切皆有可能，除了系统崩溃。<br>
        这是因为：内存是连续的，理论上合法的内存地址是 <code>0~2<sup>64</sup> - 1</code> ，因此只要是这个范围内的地址指向的 <code>byte</code>，都是可以访问的——唯一问题是这些
        <code>byte</code> 是不是你能用的——例如别的程序（包括系统）的内存区域。<b>一旦动了你不该动的数据，很可能就是你的程序<font color="Orange" size="5">寄</font>
          或被你攻击的程序<font color="Orange" size="5">寄</font>。</b></p>
      <p>但是也有一个好消息：系统不会崩，操作系统的存在意义之一就是防这个。</p>
      <p>
        <font color="#71AEE2"><b>不是，为什么我的程序会<font size="5">寄</font>？<font>¯\_(ツ)_/¯</font></b></font><br>
        <font color="#AC6E46"><b>因为系统和CPU间有某些交易（</b></font><br>
        <font color="#71AEE2"><b>那为什么系统不帮我管内存呢 (┙&gt;∧&lt;)┙へ┻┻</b></font>
      </p>
      <details>
        <summary>知识扩充：「慢着慢着，你还没讲字符串呢！」</summary>
        <blockquote><s>出现在标题不代表会讲。</s><br>字符串实际上是一种特殊的数组：
          <ol>
            <li>所有元素都是 <code>char</code>；</li>
            <li>至少有一个元素为 <code>'\0'</code>。<br>
              <span class="lumia"><code class="lumia">'\0'</code> 是一个特殊字符，ascii值是 <code
                  class="lumia">0</code>，又称0字符，用于标记字符串的结尾。</span>
            </li>
          </ol>
          <p>满足以上两条的数组才能叫字符串。例如数组：</p>
          <pre data-role="codeBlock" data-info="cpp" class="language-cpp"><span class="token keyword keyword-char">char</span> str_a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre>
          <p>等价于 <code>char str_b[] = "Hello";</code></p>
        </blockquote>
      </details>
      <h2 id="cp4"> 第四节：动态内存 </h2>
      <table>
        <tbody>
          <tr>
            <td width="80"><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#h1"><img
                  src="./Brief introdunction to pointers_files/Azoth.png"></a> </td>
            <td> <i>Perhaps it isn't the final solvent that the alchemists sought. But it will do, for our purposes.</i>
            </td>
          </tr>
        </tbody>
      </table>
      <p>在第二节的时候，我们曾经提到过一种<strong>运行期产生</strong>的、<strong>没有名字</strong>的变量：</p>
      <blockquote>
        <font color="#71AEE2"><b>难道还有没有名字的变量吗？</b></font><br>
        <font color="#AC6E46"><b>正是如此。</b></font><br>
        有一些变量本身，确实存在于内存之中，但是没有名字——因为它们并不是在编译期产生的，而是在<b>运行期产生的</b>——因此不能通过名字被直接使用。<br>
      </blockquote>
      <p>
        <font color="#71AEE2"><b>我想起来了——可是这又有什么用呢？</b></font><br>
        <font color="#AC6E46"><b>这种动态获取的内存是很多数据结构<small><span
                class="lumia">（如：链表、树、图）</span></small>的重要实现方式，在这里我暂时不会深入讲解——但是总而言之，这大有用武之地。</b></font><br>
        <font color="#71AEE2"><b>听起来有点意思，怎样获取这种动态的内存呢？</b></font>
      </p>
      <p>操作系统是内存的管理者，所有内存理论上都是操作系统进行管理的——所以要获取一块内存，得向操作系统申请——这就要用到函数 <code>malloc</code>。<br>
        它是这样用的：<code>malloc(&lt;N&gt;);</code>其中 <code>&lt;N&gt;</code> 是要申请的 <code>byte</code> 的数目。<br>
        例如要申请<code>40</code>个<code>byte</code>：<code>malloc(40);</code></p>
      <p>
        <font color="#71AEE2"><b>好极啦！现在我们拿到了40个byte的使用权——诶，等等，怎么用呢？<br>让我想想……没有变量名，有地址吗？</b></font><br>
        <font color="#AC6E46"><b>有。</b></font><br>
        <font color="#71AEE2"><b>在哪？</b></font><br>
        <font color="#AC6E46"><b>刚刚丢了。</b></font>
      </p>
      <p>实际上 <code>malloc</code> 申请完内存之后会返回一个地址，指向被申请区域的第一个<code>byte</code>，而我们为了接下来的使用，必须用一个指针去承接这个地址值。<br>
        考虑到<code>40</code>个<code>byte</code>可以看成是<code>10</code>个<code>int</code>，我们不妨用<code>int *</code>来承接这个地址。</p>
      <pre data-role="codeBlock" data-info="cpp" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token operator">*</span>pointer<span class="token punctuation">;</span> <span class="token comment">// 先整一个指针</span>
pointer <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 申请，并保存得到的地址。</span>
</pre>
      <p>现在这个 <code>pointer</code> 可以当数组用，下标范围是 <code>[0, 10)</code> 内的整数。<br>
        也就是说 <code>pointer[0]</code>、<code>pointer[1]</code>、……、<code>pointer[9]</code> 都能用。<br>
        当然，写成指针偏移的形式更清晰：<br>
        <code>*pointer</code>、<code>*(pointer + 1)</code>、……、<code>*(pointer + 9)</code>
      </p>
      <blockquote>
        <p>所有标准库里面的函数描述区间的时候都是左闭右开区间。</p>
      </blockquote>
      <p>
        <font color="Gold"><b>[WARNING: ]</b></font><b> 接下来开始提及的内容请务必认真注意。</b>
      </p>
      <p>无论什么时候使用动态内存，即使用 <code>malloc</code> 开出了内存空间，<strong>一定要记得释放</strong>。</p>
      <p>释放的方法很简单：以刚刚开的内存空间为例，只需要知道那一整段空间的第一个<code>byte</code>的地址就可以完成释放——因为操作系统是用首地址来记录内存申请记录的。<br>
        刚刚我们把开出来的内存的首地址放在了 <code>pointer</code> 里，因此现在要：</p>
      <pre data-role="codeBlock" data-info="cpp" class="language-cpp"><span class="token function">free</span><span class="token punctuation">(</span>pointer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 归还（释放）内存。</span>
pointer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 移开这个指针的指向。</span>
</pre>
      <p>这样就够了。</p>
      <details>
        <summary>知识拓展：「归还后置<code>NULL</code>」</summary>
        <blockquote>
          因为<code>free</code>完之后，<code>pointer</code> 仍然指向原来的旧地址——一个已经失去所有权的地址——继续指向这个地址有误用的风险，这是要避免的。
          使用已归还的和使用不属于自己的内存是一个性质的。
        </blockquote>
      </details>
      <h2 id="cp5"> 第五节：地址的传递 </h2>
      <table>
        <tbody>
          <tr>
            <td width="80"><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#h1"><img
                  src="./Brief introdunction to pointers_files/Consecrated_Lintel.png"></a> </td>
            <td> <i>This is the skull of a door through which power has passed.</i> </td>
          </tr>
        </tbody>
      </table>
      <p>
        <font color="DarkGreen"><b>[ATTENTION: ]</b></font><b> 本节内容将成为重要技巧。</b>
      </p>
      <p>在开始阐述本节内容之前，我们需要先回顾一下函数传参的机制。</p>
      <details>
        <summary>知识拓展：「函数传参机制」</summary>
        <blockquote>
          在有参数的函数被调用的时候，往往需要考虑传参。
          例如对于函数 <code>z = f(x, y);</code>，其中 `z` 是返回值，`x` `y` 是本地的变量。
          以一个具体的函数为例子：
          <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-int">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
          <p>当我们使用这个函数的时候：</p>
          <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-int">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> c <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
          <p>实际上过程是这样的：</p>
          <ol>
            <li>根据参数进行一一对应：<code>int x = a;</code>，<code>int y = b;</code> （注意这里 <code>x</code> 不是
              <code>a</code>，是一个新变量，只不过获得了 a 的值——而 a 在 f 外面。），这一步之后，<code>x</code> 的值是 <code>0</code>，<code>y</code> 的值是
              <code>2</code>。</li>
            <li>在 <code>f</code> 的内部，进行运算 <code>int unnamed = x + y;</code>，这里，运算完成后，隐藏变量 <code>unnamed</code> 的值是
              <code>2</code>。</li>
            <li>结束 <code>f</code> 的存在，将返回值返回到原本的位置，于是 <code>c = f(0, 2);</code> 变成了 <code>c = 2</code>。</li>
          </ol>
        </blockquote>
      </details><br>
      <p><strong>函数传参永远只会进行值的传递</strong>：你永远无法直接把「变量」的整个概念原封不动地传递进去。<br>
        实际上，传递进去的只是该变量在那一时刻的值——并用函数中的其中一个形式参数来承接这个值。<br>
        那么很显然，函数中被用于承载该值的形式参数，和原本的变量，在完成值传递之后就已经没有关系了。<br>
        <strong>形式参数是一个独立的变量，和外部赋予它值的变量毫不相关</strong>，任何对于形式参数的改动都不会对外部产生分毫的影响——这就是数学意义上的函数——除了计算之外没有副作用的函数。
      </p>
      <p>这很好——除非你的函数的实现依赖于这种副作用。</p>
      <p>例如，考虑函数，用于交换两个变量的值：</p>
      <details>
        <summary><code>swap()</code> 的无效实现</summary>
        <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-void">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span> a <span class="token operator">=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
      </details><br>
      <p>但是这种作用无法传递到外面去，例如，使用 <code>swap(x, y);</code>，<code>x</code>、<code>y</code> 的值不会受到丝毫的影响。</p>
      <p>
        <font color="#71AEE2"><b>啊淦，不会吧不会吧，参数传递全是按值传递？</b></font><br>
        <font color="#AC6E46"><b>确实如此。（摊手）</b></font><br>
        <font color="#71AEE2"><b>那不就没法修改外面的变量了吗？</b></font><br>
        <font color="#AC6E46"><b>我们可以往别的方向想想——我们可不可以绕开这个机制？</b></font>
      </p>
      <p>既然我们最终要操作的是变量，我们不妨想想它们的本质是什么——是一段内存区域——那么它们就肯定在内存上；更进一步地，很显然，所有变量自从开始存在，就会在内存上占有一段固定的区域——因此地址也是固定的。</p>
      <p><strong>所以我们要传递的，是地址。</strong></p>
      <p>刚刚的代码可以实现成这样：</p>
      <details>
        <summary><code>swap()</code> 的指针实现</summary>
        <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-void">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> <span class="token operator">*</span>p_a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> <span class="token operator">*</span>p_b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> c <span class="token operator">=</span> <span class="token operator">*</span>p_a<span class="token punctuation">;</span> <span class="token operator">*</span>p_a <span class="token operator">=</span> <span class="token operator">*</span>p_b<span class="token punctuation">;</span> <span class="token operator">*</span>p_b <span class="token operator">=</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
      </details><br>
      <p>使用 <code>swap(&amp;x, &amp;y);</code> 来完成交换。</p>
      <p>
        <font color="#71AEE2"><b>这也太作弊了吧？这是怎么做到修改了外面的变量的？<code>p_a</code> 和 <code>p_b</code> 不会影响到外面的
            <code>&amp;x</code> 和 <code>&amp;y</code> 啊？</b></font><br>
        <font color="#AC6E46"><b>确实没有，但我们本来想动的就是地址背后的东西——<code>x</code> 和 <code>y</code> 本身。操作 <code>p_a</code> 和
            <code>p_b</code> <span class="lumia">像嘉心糖一样</span>什么用都没有，但是 <code>*p_a</code> 和 <code>*p_b</code> 真的就等价于外面的
            <code>x</code> 和 <code>y</code> 啊。</b></font>
      </p>
      <p>这种技巧更多用于数组的传递。<br>
        数组作为一种连续的内存区域，完成传递只需要三种信息：</p>
      <ol>
        <li>其中一个元素的地址</li>
        <li>基于该元素确定的下标范围</li>
        <li>所有元素的类型</li>
      </ol>
      <p>完成这三种信息的传递，其中一种组合就是：</p>
      <ul>
        <li>数组第一个元素的地址以及类型（地址+类型 也就是一个指针相当的信息）</li>
        <li>从该元素开始计算的，数组长度。（由于是首地址，因此只需要记录总长，首地址前不再有元素。）</li>
      </ul>
      <p>——实际上这就是数组本身的组织方式。</p>
      <p>对于某些特殊的数组，如果已知用固定的元素作为结尾，例如
        <code>0</code>，并且保证此元素在整个数组中必定存在且出现在结尾，那么就不需要额外传递数组长度——因为数组长度可以由数据本身给出——这类数组的典型例子就是字符串。<span
          class="lumia"><s>忘了就翻前面的知识扩充。</s></span></p>
      <details>
        <summary>例子：获取字符串的长度</summary>
        <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-long">long</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-int">int</span> <span class="token function">get_length</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token operator">++</span>r<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
      </details><br>
      <details>
        <summary>知识扩充：引用的直接使用</summary>
        <blockquote>在点开下面的代码实现前请三思：你到底对计算机有没有兴趣？<br><b>我是说，<ruby>计算机科学<rt>Computer Science</rt>
              </ruby></b>。<br>这是一种很简便的写法，但是背后的原理大有不同，将涉及到一个新的领域。<div align="right">——在敲开新世界的大门之前，这是最后的忠告。</div>
          <details>
            <summary><code>swap()</code> 的引用实现（<b>仅限C++</b>）</summary>
            <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-void">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> <span class="token operator">&amp;</span>ref_a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> <span class="token operator">&amp;</span>ref_b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> c <span class="token operator">=</span> ref_a<span class="token punctuation">;</span> ref_a <span class="token operator">=</span> ref_b<span class="token punctuation">;</span> ref_b <span class="token operator">=</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
            <p>篇幅有限，不再解释这段代码，以及<ruby>「引用」<rt>Reference</rt></ruby>有关的所有知识。</p>
          </details>
        </blockquote>
      </details>
      <h2 id="cp6"> 第六节：函数指针与高阶函数初步 </h2>
      <table>
        <tbody>
          <tr>
            <td width="80"><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#h1"><img
                  src="./Brief introdunction to pointers_files/Frangiclave.png"></a> </td>
            <td> <i>There are keys that open doors; then there are keys that destroy them. --It cannot be locked away.
                Keep it in the hand or beneath the tongue.</i> </td>
          </tr>
        </tbody>
      </table>
      <p>
        <font color="#71AEE2"><b>既然指针可以指向变量——也就是储存变量的地址——它是否可以储存别的地址呢？</b></font><br>
        <font color="#AC6E46"><b>这实际上是完全可以的。</b></font>
      </p>
      <p><em>在开始讲述本章内容之前，我们不妨了解一些程序运行的简单知识。</em></p>
      <details>
        <summary>知识扩充：程序运行的地点</summary>
        <blockquote>
          显然而且毫无疑问地，所有程序运行时，都需要把自己的机器码<small><span
              class="lumia">也就是二进制指令</span></small>载入内存——这包括所有操作数据的代码，也就是我们通常意义上所说的函数。
          也就是说，一旦程序开始运行，它的有关文件就会从硬盘上被读入到内存中去，产生一个程序实体——实际被执行的是这个实体——一个完全在内存上的实体。
          换而言之，在程序运行的时候完全可以获取任何自己的组件——包括所有函数——的地址。
        </blockquote>
      </details><br>
      <blockquote>
        <p>本章主要讨论的问题是：如何用一种类似于获取变量地址和利用地址使用变量的方法，来获取函数的地址以及利用必要的信息来使用指定地址的函数。<br>
          很显然，结合标题，读者可以猜出本章讲述的是函数指针——一种用于储存函数地址和一定的信息的变量。<br>
          一般来说，函数指针在 <code>C++</code> 中有至少两种，但是在 <code>C</code> 中只有一种。由于这里主要介绍 <code>C</code>，因此默认函数指针只有一种：普通函数指针。</p>
      </blockquote>
      <p>函数指针的概念和普通指针几乎一致，因此我们将使用类似的方式引出函数指针的概念。<br>
        首先，我们先复习一个函数的构成部分。<small><span class="lumia">（注：也就是要正确的调用一个函数需要多少信息。）</span></small></p>
      <p><strong>函数的构成三要素：</strong></p>
      <ol>
        <li>函数的唯一标识符</li>
        <li>函数的调用方式</li>
        <li>函数的返回值</li>
      </ol>
      <details>
        <summary>详细解释：以上三要素的意义</summary>
        <blockquote>
          <p><strong>首先是函数的返回值</strong>，这决定了函数返回值的类型，因此是一个和变量的类型一样重要的信息。<br>
            <strong>其次是函数的调用方式</strong>，也就是函数的参数列表，决定了这个函数会用什么参数进行调用。这很好理解。<br><br>
            <font color="#71AEE2"><b>但是“函数的唯一标识符”又是什么？</b></font><br>
            <font color="#AC6E46"><b>这其实是一个很常见的概念，在<code>C</code> 里面，它就是函数的<font size="5">名称</font>。因此 <code>C</code>
                中的函数是不能重名的——以确保函数具有唯一的标识。</b></font><br><br>
            <strong>唯一的标识+返回值，这就是调用函数和处理函数返回值所需要的所有信息。</strong><small><span class="lumia">但是在 <code
                  class="lumia">C++</code> 中允许函数重载，因为 <code class="lumia">C++</code> 有一套<ruby>名称粉碎<rt class="lumia">Name
                    Mangling</rt></ruby>机制。</span></small>
          </p>
        </blockquote>
      </details><br>
      <p>显然，当我们使用函数指针的时候，也应该还原这三种信息。</p>
      <p>首先是函数的唯一标识符——储存函数的地址就可以解决<small><span
            class="lumia">唯一标识符不仅有函数名，还有地址。</span></small>；其次是函数的调用方式（参数列表）和返回值——<code>C</code>
        采用的是和变量类似的处理方式——一并写在函数指针的“类型”里面。</p>
      <p>由于概念相对于介绍普通指针时较少，而较难，本章采用直接给例子的方式进行讲解。</p>
      <h3>例子：写一个函数指针</h3>
      <p>对于如下函数声明：</p>
      <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-int">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-float">float</span><span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
      <p>对应的函数指针声明是：</p>
      <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-int">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p_f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-float">float</span><span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
      <p>赋值方式是：</p>
      <pre data-role="codeBlock" data-info="c" class="language-c">p_f <span class="token operator">=</span> func<span class="token punctuation">;</span> <span class="token comment">// 不需要 &amp;</span>
</pre>
      <p>调用函数指针指向的函数的方式是：</p>
      <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 普通函数</span>
<span class="token function">p_f</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数指针，不需要 *</span>
</pre>
      <p>注意到函数指针的声明方式和函数的声明方式基本上保持了一致，<br>只是将原来 <code>函数名</code> 的部分替换成了 <code>(*指针名)</code>，所以总结一下可以得出通式：</p>
      <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token comment">// 对于函数声明</span>
<span class="token operator">&lt;</span>return_type<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>func_name<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>param_list<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 对应的函数指针是</span>
<span class="token operator">&lt;</span>return_type<span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">&lt;</span>pointer_name<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>param_list<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
      <p>实际上，函数指针的“类型”就是 <code>&lt;return_type&gt;(&lt;param_list&gt;)</code>，这里面已经包含了参数列表和返回值的信息。</p>
      <p>
        <font color="#71AEE2"><b>但是函数指针又有什么用呢？</b></font><br>
        <font color="#AC6E46"><b>其中一种用法是用于实现某些同构的算法——例如累加、累乘等。因此对于这个问题，我更乐意直接给出一个例子。</b></font>
      </p>
      <h3>例子：累积操作</h3>
      <p>考虑一类问题：一列连续的被操作数上进行累积的二元可交换操作，例如：累加、累乘等。<br>
        考虑到这些操作都具有可交换性，<small><span class="lumia">（例如 <code
              class="lumia">a+b==b+a</code>）</span></small>我们可以通过递归大幅降低操作次数。<small><span class="lumia">（从 <code
              class="lumia">O(n)</code> 到 <code class="lumia">O(log n)</code>）</span></small><br>
        对此类问题总结出如下递归公式：</p>
      <ul>
        <li>设 <code>S(a, b)</code> 为数组 <code>A[n]</code> 在 <code>[a, b)</code> 区间内的整体操作结果，其中 <code>b ≤ n</code>，<br>
          我们有：
          <ol>
            <li><code>S(a, b) = F(S(a, k), S(k, b))</code>，<br>
              其中 <code>k ∈ [a, b)</code>；<code>F(x, y)</code> 是一个二元可交换操作，例如加、乘等。</li>
            <li><code>S(a, a) = A[a]</code></li>
          </ol>
        </li>
      </ul>
      <details>
        <summary>一个具体的例子</summary>
        <blockquote>
          <s>我感觉不举实例这里不好理解</s>
          <p>考虑操作为加法操作，即整体操作结果为区间累加。<br>
            以 <code>F(x, y) = x + y</code> 代入，我们可以获得具体例子：</p>
          <ul>
            <li>设 <code>S(a, b)</code> 为数组 <code>A[n]</code> 在 <code>[a, b)</code> 区间内的整体操作结果，其中 <code>b ≤ n</code>，<br>
              我们有：
              <ol>
                <li><code>S(a, b) = S(a, k) + S(k, b)</code>，<br>
                  其中 <code>k ∈ [a, b)</code>；</li>
                <li><code>S(a, a) = A[a]</code></li>
              </ol>
            </li>
          </ul>
          <p>这是上面看起来比较抽象的递归公式用加法代入后得到的一个例子。同理，由于操作结构是一致的，我们可以用乘法、<em>与</em>、<em>或</em> 等代入来得到累乘、累与、累或的例子。</p>
        </blockquote>
      </details><br>
      <p><code>C</code> 代码实现：</p>
      <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">(</span><span class="token operator">*</span>binary_op<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> b<span class="token punctuation">,</span> binary_op F<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> A<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token function">accumulate</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> a<span class="token punctuation">,</span> k<span class="token punctuation">,</span> F<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> k<span class="token punctuation">,</span> b<span class="token punctuation">,</span> F<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
      <p>这实际上定义了一个参数中包含函数的高阶函数 <code>accumulate</code>，现在我们分别它用于加法、乘法、异或：</p>
      <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token comment">// 加法</span>
<span class="token keyword keyword-int">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token comment">// 乘法</span>
<span class="token keyword keyword-int">int</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token comment">// 异或</span>
<span class="token keyword keyword-int">int</span> <span class="token function">xor</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> x <span class="token operator">^</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>
</pre>
      <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token comment">// 分别求同一个数组 A[n] 的 [a, b) 区间的累操作：</span>
<span class="token comment">// 累加：</span>
<span class="token keyword keyword-int">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> add<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 累乘：</span>
<span class="token keyword keyword-int">int</span> prod <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> mul<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 累异或：</span>
<span class="token keyword keyword-int">int</span> xor_sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> xor<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
      <p>这样的高阶函数有很多，包括 <code>C++ STL</code> 中 <code>algorithm</code> 的 <code>std::sort</code>
        函数。高阶函数可以让算法结构和操作本身分离，从而实现代码的复用。<br></p>
      <details>
        <summary>知识扩充：高阶函数</summary>
        <blockquote>
          <blockquote>
            <h5>Higher-order function</h5>
            In mathematics and computer science, a higher-order function is a function that does at least one of the
            following:
            <ul>
              <li>takes one or more functions as arguments (i.e. a procedural parameter, which is a parameter of a
                procedure that is itself a procedure),</li>
              <li>returns a function as its result.</li>
            </ul>
            <p>All other functions are first-order functions. In mathematics higher-order functions are also termed
              operators or functionals. The differential operator in calculus is a common example, since it maps a
              function to its derivative, also a function.</p>
            <div align="right"><small>From Wikipedia, the free encyclopedia</small></div>
          </blockquote>
          <strong>机翻：</strong><br>
          在数学和计算机科学中，高阶函数是至少执行以下一项的函数：
          <ul>
            <li>将一个或多个函数作为参数（即过程参数，它是过程的参数，本身就是一个过程），</li>
            <li>返回一个函数作为其结果。</li>
          </ul>
          <p>所有其他函数都是一阶函数。在数学中，高阶函数也被称为算子或泛函。微积分中的微分算子就是一个常见的例子，因为它将函数映射到它的导数，也是一个函数。</p>
        </blockquote>
      </details>
      <details>
        <summary>知识扩充：STL 中的 <code>std::sort</code></summary>
        <blockquote>
          <table>
            <tbody>
              <tr>
                <td>
                  <table>
                    <tbody>
                      <tr>
                        <td colspan="2"><strong>基本信息</strong></td>
                      </tr>
                      <tr>
                        <td>适用语言</td>
                        <td>仅 <code>C++</code></td>
                      </tr>
                      <tr>
                        <td>所在头文件</td>
                        <td><code>algorithm</code></td>
                      </tr>
                      <tr>
                        <td>所在 namespace</td>
                        <td><code>std</code></td>
                      </tr>
                      <tr>
                        <td>全名</td>
                        <td><code>std::sort</code></td>
                      </tr>
                      <tr>
                        <td colspan="2">
                          <div align="center"><strong>实例见右→</strong></div>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </td>
                <td>
                  <pre data-role="codeBlock" data-info="cpp" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> vec<span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">3.4</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">6.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">32.1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.123</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> <span class="token function">greater</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> x <span class="token operator">&gt;</span> y<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Before sort: -3.4, 2.3, -6.0, 2.0, 32.1, -0.123</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> x <span class="token operator">:</span> vec<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> greater<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// After sort: 32.1, 2.3, 2.0, -0.123, -3.4, -6.0</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> x <span class="token operator">:</span> vec<span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre>
                </td>
              </tr>
            </tbody>
          </table>
        </blockquote>
      </details><br>
      <p>
        <font color="#71AEE2"><b>使用高阶函数实现同构的算法这确实是很有意义的用法——可是作为一个新手我根本不会写啊！！！</b></font><br>
        <font color="#AC6E46"><b>这就是函数指针最有意义的用法了——这不但是极具理论价值的<small><a
                href="https://plato.stanford.edu/entries/lambda-calculus/">(Lambda
                Calculus)</a></small>，也是极具工程价值的<small><a
                href="https://www.geeksforgeeks.org/callbacks-in-c/#:~:text=A%20callback%20is%20any%20executable%20code%20that%20is,it%20will%20be%20called%20as%20a%20Callback%20function.">(Callback
                Functions and Internet)</a></small>。事实上，作为新手写不出来是很正常的——但是稍微接触一下对于使用别人写好的东西总是有帮助的。</b></font>
      </p>
      <p>当然，这节的内容不能理解完全是无关紧要的——如果不是对计算机感兴趣的话。<br>
        事实上，即使是学习计算机有关专业的学生，这节的理解也是无关紧要的——总有一天你会在实践中理解这一切。<br>
        <span class="lumia">（如果是数学专业或者计算机专业的学生，先了解 Lambda Calculus 会对理解本节有帮助。）</span>
      </p>
      <h2 id="cp7">序章：结束与开始</h2>
      <table>
        <tbody>
          <tr>
            <td width="80"><a href="file:///tmp/mume2022931-3827-5wmtjh.81tl9.html#h1"><img
                  src="./Brief introdunction to pointers_files/Port_Noon.png"></a> </td>
            <td> <i>Rose is a rose is a rose. Loveliness extreme. Extra gaiters, Loveliness extreme. Sweetest ice-cream.
                Pages ages page ages page ages.</i> </td>
          </tr>
        </tbody>
      </table>
      <p>这篇面向 <code>C</code> 的指针入门到这里就结束了。</p>
      <p>从最初的内存模型到利用指针实现的动态内存管理，再到指针和数组与字符串的联系——这不是一篇短的文章，但对于指针来说也确实只能算是入门。同时，这篇文章集中于介绍 <code>C</code> 的指针，在
        <code>C++</code> 中，内存分配机制有了比较大的变化——但是只要保证分配使用的是 <code>malloc</code>、<code>realloc</code>、<code>calloc</code>
        而释放使用的是 <code>free</code>，这篇文章也可以算是合格的 <code>C++</code> 指针入门。</p>
      <p>如果这篇文章能引起你对于 <code>C</code> 指针的兴趣的话，或者是对 <code>C</code> 的兴趣的话，也许也可以算是一个开始。</p>
      <p>这篇指针作为简单的指针入门，没有介绍链表等离散的数据结构的实现，因为它们在纯 <code>C</code>
        下的实现巧妙而对初学者困难。作为一篇入门文章，打击初学者不是必要的。但是看完这篇文章之后，在恰当的时候，不妨看看链表的概念与实现。</p>
      <p>也许我还会去写下一篇，详细介绍 <code>C++</code> 的指针入门，也许不会。成文虽然尚且幼稚粗糙，但过程中耗费了许多心力，也该休息一下了。</p>
      <h3>Farewell, Amigo</h3>
      <p>在这篇文章的最后，附上简单的链表实现：</p>
      <details>
        <summary>源码，可以收下。（极长预警）</summary>
        <blockquote>
          <pre data-role="codeBlock" data-info="c" class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">list_of_double_h</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">list_of_double_h</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-int">int</span> <span class="token class-name">size_t</span><span class="token punctuation">;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>_next<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>_previous<span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> __data<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__LIST_OF_double</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>_holder_node<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>_visitor_node<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> _size<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> _at_visit<span class="token punctuation">;</span>
<span class="token punctuation">}</span> list_double<span class="token punctuation">;</span>
list_double <span class="token operator">*</span><span class="token function">list_double_create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    list_double <span class="token operator">*</span>res <span class="token operator">=</span> 
        <span class="token punctuation">(</span>list_double <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">__LIST_OF_double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token operator">-&gt;</span>_holder_node <span class="token operator">=</span> 
        <span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token operator">-&gt;</span>_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    res<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> res<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    res<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_previous <span class="token operator">=</span> res<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    res<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> res<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
    res<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">list_double_push_back</span><span class="token punctuation">(</span>list_double <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> with<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>p <span class="token operator">=</span> 
        <span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>_previous <span class="token operator">=</span> to<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_previous<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> to<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>__data <span class="token operator">=</span> with<span class="token punctuation">;</span>
    to<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_previous<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> p<span class="token punctuation">;</span>
    to<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_previous <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>to<span class="token operator">-&gt;</span>_at_visit <span class="token operator">||</span> <span class="token operator">!</span>to<span class="token operator">-&gt;</span>_size<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        to<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> to<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        to<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>to<span class="token operator">-&gt;</span>_size<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">list_double_push_head</span><span class="token punctuation">(</span>list_double <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> with<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>p <span class="token operator">=</span> 
        <span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>_previous <span class="token operator">=</span> to<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> to<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>__data <span class="token operator">=</span> with<span class="token punctuation">;</span>
    to<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token operator">-&gt;</span>_previous <span class="token operator">=</span> p<span class="token punctuation">;</span>
    to<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>to<span class="token operator">-&gt;</span>_at_visit <span class="token operator">||</span> <span class="token operator">!</span>to<span class="token operator">-&gt;</span>_size<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        to<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> to<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        to<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>to<span class="token operator">-&gt;</span>_size<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-double">double</span> <span class="token function">list_double_at</span><span class="token punctuation">(</span>list_double <span class="token operator">*</span>which<span class="token punctuation">,</span> <span class="token class-name">size_t</span> index<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>which<span class="token operator">-&gt;</span>_size<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"ERROR: on at() of empty list."</span><span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> which<span class="token operator">-&gt;</span>_size<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"ERROR: on at() with invaild index.\n"</span><span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>needle <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_visitor_node<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>stop <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> at <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_at_visit<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> half <span class="token operator">=</span> <span class="token punctuation">(</span>which<span class="token operator">-&gt;</span>_size<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>at <span class="token operator">&gt;</span> index<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>at <span class="token operator">-</span> index<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> at<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> half<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>at <span class="token operator">&gt;</span> half<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            needle <span class="token operator">=</span> stop<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
            at <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span>
        <span class="token punctuation">{</span>
            needle <span class="token operator">=</span> stop<span class="token operator">-&gt;</span>_previous<span class="token punctuation">;</span>
            at <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>at <span class="token operator">&lt;</span> index<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        needle <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        <span class="token operator">++</span>at<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>at <span class="token operator">&gt;</span> index<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        needle <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_previous<span class="token punctuation">;</span>
        <span class="token operator">--</span>at<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    which<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> at<span class="token punctuation">;</span>
    which<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> needle<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> needle<span class="token operator">-&gt;</span>__data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">list_double_remove</span><span class="token punctuation">(</span>list_double <span class="token operator">*</span>which<span class="token punctuation">,</span> <span class="token class-name">size_t</span> index<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>which<span class="token operator">-&gt;</span>_size<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"ERROR: on remove() of empty list."</span><span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>needle <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_visitor_node<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>stop <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> at <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_at_visit<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>at <span class="token operator">&lt;</span> index<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>needle <span class="token operator">==</span> stop<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"ERROR: on remove() with up-outbounded index.\n"</span><span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        needle <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        <span class="token operator">++</span>at<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>at <span class="token operator">&gt;</span> index<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>needle <span class="token operator">==</span> stop<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"ERROR: on remove() with down-outbounded index.\n"</span><span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        needle <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_previous<span class="token punctuation">;</span>
        <span class="token operator">--</span>at<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>needle<span class="token operator">-&gt;</span>_previous <span class="token operator">!=</span> stop<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        which<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_previous<span class="token punctuation">;</span>
        which<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> at <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>needle<span class="token operator">-&gt;</span>_next <span class="token operator">!=</span> stop<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        which<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        which<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> at <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
    <span class="token punctuation">{</span>
        which<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        which<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    needle<span class="token operator">-&gt;</span>_previous<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
    needle<span class="token operator">-&gt;</span>_next<span class="token operator">-&gt;</span>_previous <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_previous<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">--</span>which<span class="token operator">-&gt;</span>_size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-double">double</span> <span class="token function">list_double_pop_back</span><span class="token punctuation">(</span>list_double <span class="token operator">*</span>which<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-double">double</span> ret<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>which<span class="token operator">-&gt;</span>_size<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"ERROR: on pop() of empty list."</span><span class="token punctuation">,</span> <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>res <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_previous<span class="token punctuation">;</span>
    res<span class="token operator">-&gt;</span>_previous<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_previous <span class="token operator">=</span> res<span class="token operator">-&gt;</span>_previous<span class="token punctuation">;</span>
    <span class="token operator">--</span>which<span class="token operator">-&gt;</span>_size<span class="token punctuation">;</span>
    ret <span class="token operator">=</span> res<span class="token operator">-&gt;</span>__data<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>which<span class="token operator">-&gt;</span>_at_visit<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        which<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        which<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-double">double</span> <span class="token function">list_double_pop_head</span><span class="token punctuation">(</span>list_double <span class="token operator">*</span>which<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-double">double</span> ret<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>which<span class="token operator">-&gt;</span>_size<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"ERROR: on pop() of empty list."</span><span class="token punctuation">,</span>
              <span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>res <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
    res<span class="token operator">-&gt;</span>_next<span class="token operator">-&gt;</span>_previous <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> res<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
    <span class="token operator">--</span>which<span class="token operator">-&gt;</span>_size<span class="token punctuation">;</span>
    ret <span class="token operator">=</span> res<span class="token operator">-&gt;</span>__data<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>which<span class="token operator">-&gt;</span>_at_visit<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        which<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        which<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">list_double_clear</span><span class="token punctuation">(</span>list_double <span class="token operator">*</span>which<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>needle <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>stop <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>needle <span class="token operator">!=</span> stop<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> needle<span class="token punctuation">;</span>
        needle <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    which<span class="token operator">-&gt;</span>_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    which<span class="token operator">-&gt;</span>_visitor_node <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
    which<span class="token operator">-&gt;</span>_at_visit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">list_double_delete</span><span class="token punctuation">(</span>list_double <span class="token operator">*</span>which<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>needle <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>stop <span class="token operator">=</span> which<span class="token operator">-&gt;</span>_holder_node<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>needle <span class="token operator">!=</span> stop<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">__NODE_OF_double</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> needle<span class="token punctuation">;</span>
        needle <span class="token operator">=</span> needle<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>which<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">//list_of_double_h</span></span>
</pre>
        </blockquote>
      </details>
      <blockquote>
        <p>这是一份仿 C++ STL 接口的环链表实现源码，只实现了double类型。仅当学习之用。<br>
          现在的你也许不会看懂它，但是你总会有与它再相见的时候——为了某种目的：也许是成绩，也许是技能。<br>
          但我决定将这作为全篇文字仅有的复杂实现放在这里，<br>
          作最后的道别。</p>
      </blockquote>
    </div>


  </div>










</body>

</html>